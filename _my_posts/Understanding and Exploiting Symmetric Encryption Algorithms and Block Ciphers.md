---
layout: post
title: "Understanding and Exploring Symmetric Encryption Algorithms and Block Ciphers"
---

# Understanding and Exploring Symmetric Encryption Algorithms and Block Ciphers

When we talk about exploring encryption algorithms, it is common to imagine a certain level of integrity, usually loaded with reliability in the security of certain data. However, some of the methods used for data encryption have weaknesses in their algorithms. Throughout this publication, I intend to address one of these examples, going through brief introductory notions to the exploration that will follow, aiming to demonstrate the importance of concern and understanding (even if superficial) of data protection.

## Understanding Symmetric Encryption Algorithms

Symmetric encryption algorithms are algorithms that use the same *cryptographic key* for both encryption and decryption of any given data. This key is a secret shared privately between the sender and the receiver of the data, being used in both the initial and final processes.

And here lies one of the main problems of symmetric key encryption: the requirement that both the sender and the receiver of the information must have access to the same key, under the premise that it will only be known to these supposed parties. This means that anyone who intercepts this cryptographic key will have access to the original sensitive data.

![ass](https://www.gta.ufrj.br/ensino/eel879/trabalhos_vf_2008_2/hugo/NotesImages/Topic12NotesImage1.jpg)

Symmetric encryption has two common types of ciphers for use:

Stream ciphers: Encrypt content by generating a pseudo-random bit stream (called a key stream) that, when combined with the content (be it text, an image, a video, etc.), generates the ciphertext. An example of a stream cipher is RC4.

Block ciphers: Encrypt a fixed-size set of bytes, called a block. Messages that are not the size of the block or a multiple of it need to be adjusted by padding with additional (unnecessary) data so that the message size is appropriate for use with this type of cipher. An example of a block cipher is AES.

## Understanding Block Ciphers and the ECB Mode

In cryptography, a block cipher is a deterministic algorithm that operates on fixed-size groups of bits (data blocks), usually 64 or 128 bits, called **blocks**, with an invariant transformation specified by a symmetric key. Any given data is divided into fixed-size blocks by the algorithm, which operates on each block independently, generating an encrypted result **of the same size B** encrypted by a key *K*.

In the case of ECB (Electronic Codebook) mode, our message is divided into blocks, and each block is encrypted **separately**.

![1](/assets/images/ecb/1.png)

The cipher operates on a plaintext block of *n* bits to produce a ciphertext block of the same size *n*, having 2^n different possible plaintext blocks.

For n = 4, we would have:

[0000  
0001  
0010  
...  
1111]

Let’s look at an example of encryption with a specific configuration for an input n = 4 in [0,0,0,1].

![2](/assets/images/ecb/2.png)

And where does the problem lie? In statistical analysis!

Suppose this cipher with n = 4 was used to encrypt a data stream in a real system.  
Since the block size is small (4 bits), this cipher would be vulnerable to statistical analysis attacks on the ciphertext. If an attacker captures the ciphertext "0100", they know that the plaintext used in this block sequence is one of 2^4, or 16 possibilities, making it easily mappable (of course, for small n sizes).

Another problem we encounter is the almost inevitable repetition. If the same plaintext block repeats, the resulting ciphertext will always be the same, which can create a mappable repetition pattern for an attacker.

## Understanding the AES Algorithm

The AES (Advanced Encryption Standard) algorithm, also known as Rijndael, is a symmetric algorithm, a subset of block ciphers (seen above) with block sizes of 128 bits, but key lengths of 128, 192, and 256 bits. It operates on a two-dimensional array of bytes with 4x4 positions, called the **state**. To encrypt, each AES round (except the last) consists of four stages:

### AddRoundKey

In the AddRoundKey step, the subkey is combined with the state. For each round, a subkey is derived from the main key using Rijndael's key schedule; each subkey is the same size as the state. The subkey is added by combining each byte of the state with the corresponding byte of the subkey using the bitwise XOR operation.

![3](/assets/images/ecb/3.png)

### SubBytes Step

In the SubBytes step, each byte in the array is updated using an 8-bit S-box. To prevent attacks based on simple algebraic properties, the S-box is constructed by combining an inversion function with an invertible affine transformation. The S-box is also chosen to avoid any fixed points.

![4](/assets/images/ecb/4.png)

### ShiftRows

The ShiftRows step operates on the rows of the state, shifting the bytes in each row by a certain number of positions. In AES, the first row remains unchanged. Each byte in the second row is shifted one position to the left. Similarly, the third and fourth rows are shifted by two and three positions, respectively. For 128-bit and 192-bit block sizes, the shift pattern is the same. Thus, each column of the state at the end of the ShiftRows step is composed of bytes from all columns of the input state.

For 256-bit blocks, the first row remains unchanged, while the second, third, and fourth rows are shifted. The shifts are by 1, 2, and 4 bytes, respectively—although this change applies only to Rijndael when used with a 256-bit block, which does not occur in AES.

![5](/assets/images/ecb/5.png)

### MixColumns

This is a mixing operation that operates on the columns of the state and combines the four bytes of each column using a linear transformation. The 4 bytes of each column of the state are combined using an invertible linear transformation, such as matrix multiplication, providing diffusion to the cipher.

![6](/assets/images/ecb/6.png)

# Practical Example of a Bit-Flipping Attack

Let’s analyze the following code:

```php
<html>
<body>
  <h1>Netrunner Encryption Tool</h1>
  <a href="netrun.txt">Source Code</a>
  <form method=post action="crypto.php">
  <input type=text name="text_to_encrypt">
  <input type="submit" name="do_encrypt" value="Encrypt">
  </form>

<?php

function pad_data($data)
{
    $flag = "flag{wouldnt_y0u_lik3_to_know__}"; 
    
    $pad_len = (16 - (strlen($data.$flag) % 16));
    $retorno =  $data . $flag . str_repeat(chr($pad_len), $pad_len);
    echo '$pad_len='.$pad_len;
    echo '$data='.$data."\n";
    echo '$retorno='.$retorno."\n";
    return $retorno;
}

if(isset($_POST["do_encrypt"]))
{
  $cipher = "aes-128-ecb";
  $iv  = hex2bin('00000000000000000000000000000000');
  $key = hex2bin('74657374696E676B6579313233343536');
  echo "</br><br><h2>Encrypted Data:</h2>";
  $ciphertext = pad_data($_POST['text_to_encrypt']);
  $ciphertext = openssl_encrypt(pad_data($_POST['text_to_encrypt']), $cipher, $key, 0, $iv); 

  echo "<br/>";
  echo "<b>$ciphertext</b>";
}
?>
</body>
```

It is noticeable that the code uses the **AES** algorithm seen above to encrypt our "Flag," which can be understood as any other sensitive data we should not have access to. The code performs the "fusion" of a user input with our Flag.

Bit-flipping consists of controlling the initial value of data (plaintext) by controlling certain input values. How so?

```php
    $retorno =  $data . $flag . str_repeat(chr($pad_len), $pad_len);
```

It receives our "Data" value and adds the "Pad" value.

```php
    $pad_len = (16 - (strlen($data.$flag) % 16));
```

We can see that it is 16 bytes per block. Remember when we mentioned the possibility of a statistical analysis attack? Well... Let’s revisit our initial example of 4 bits:

Suppose our input is the word "Stars." Knowing that our imaginary block size is 4, we can arrange our input + "flag" as follows:

[s,t,a,r,s] + [f,l,a,g]. Notice that our input is larger than 4. In this case, what would happen?

We would have an arrangement like this:

[s,t,a,r] [s,f,l,a] [g,x,x,x], where X would be any padding character. Notice that our string was reallocated to fit into 4-sized blocks. Based on this principle, what would happen if, instead of passing one character, we passed one less?

[s,t,a] + [f,l,a,g] would convert to [s,t,a,f] [l,a,g,x], and what we would receive would be a specific value for the "value we pulled" (e.g., 123). From there, you can already imagine what needs to be done, but if you still don’t understand, let me explain.

[s,t,a] + [f,l,a,g] would convert to [s,t,a,f] [l,a,g,x], and this return would give us an encrypted value '123321' corresponding to this block. Knowing this final result, our input would now be:

[s,t,a,f] [l,a,g,x] would convert to [s,t,a,X] [f,l,a,g], where this time, X would be a random value generated for our brute force attack, which, considering the key and block size, would not take much time. For each result of [s,t,a,X] + [f,l,a,g], we would get a returned value, and we would compare it to see if the encrypted value returned with our random character X matches the encrypted return of [s,t,a,f] + [l,a,g,x]. When the comparison is true, we discover one character of the original text, and this process is repeated until we have the "complete text," which, in this case, is the value of "FLAG."

![7](/assets/images/ecb/7.png)

By sending an empty request (text_to_encrypt without input parameters) and analyzing the return with xxd, we can see that the output returns 32 characters (128 bits per block) starting with "4434" and ending with 0a. Now, we make inputs by adding values, in this case, 16 at a time. Our goal is to see this same return 4434...0a, as this way, we know that our input "correctly occupied the blocks," given that the "complete/empty" return is 4434...0a.

![8](/assets/images/ecb/8.png)

Notice that, by adding 16 characters (in this case, zeros) to the input, we can return our initial output 4434...0a. That is, everything above this offset belongs to us, and everything below belongs to the "FLAG" we want, and thus we know the exact size of our input block.

Now, if we remove one "Zero" from the input characters we sent, we can see that, just like in the star + flag example, the addresses were modified since the block belonging to the flag had one byte "pulled" to fill our missing "Zero."

![9](/assets/images/ecb/9.png)

Now, we know that our flag starts with the string "FLAG" (as seen in the PHP code). Thus, what we must do is, knowing that the first letter is F, send the request with an additional F. If the return of the addresses with the F is the same as before (which, in theory, pulled the F to occupy the missing "Zero" we removed), we can confirm that the first character is the letter F. Of course, in this case, we have prior information that the string starts with the letter F, but if we didn’t know, we would simply perform a brute force attack on characters until we got the same result.

![10](/assets/images/ecb/10.png)

As we can see in the image, the return was exactly the same (something that wouldn’t happen if we entered an A, B, N, Y...), thus confirming the first character of our supposed "secret data we shouldn’t have access to."

And so, we have our attack performed, demonstrating the vulnerability that can exist in block ciphers in general. For real-world environments, this process tends to be automated with some programming language, making the process incomparably faster and more effective.

# Conclusions

As we have seen throughout the publication, the danger of encryption ciphers is not only present but real, and understanding the existence of this type of attack allows not only the addition of technical knowledge but also the understanding that the advances of Science and Technology as a whole come as a benefit, showing us that evolving is always necessary, and that investment in information security sectors allows researchers, mathematicians, and any other scientific collaborators to always add more and more to the cyber world, providing increasingly secure and integral experiences.

# References

- [TenableCTF - Netrunner Encryption, by Sql3t0](https://www.youtube.com/watch?v=JTgy1gYyaSY)

- [Block cipher mode of operation at WIKIPEDIA](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)

- [Advanced Encryption Standard at WIKIPEDIA](https://pt.wikipedia.org/wiki/Advanced_Encryption_Standard)

- [Symmetric Key Algorithms at WIKIPEDIA](https://pt.wikipedia.org/wiki/Algoritmo_de_chave_sim%C3%A9trica)